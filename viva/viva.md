# Устные вопросы

### 1. Какой самый эффективный способ конкатенации строк?

- strings.Builder, поскольку минимизирует количество аллокаций.

### 2. Что такое интерфейсы, как они применяются в Go?

- Это абстрактный тип, определяющий множество функций, которые необходимо
реализовать для типа, чтобы его можно было считать экземпляром интерфейса.
Используется для опеределения поведения других типов. Следует применять,
когда необходимо гарантировать выполнение определенных условий и обеспечить
определенное поведение, ожидаемое от элемента.

### 3. Чем отличаются RWMutex от Mutex?

- RWMutex позволяет одновременно получать доступ к чтению для нескольких горутин,
Mutex же блокирует ресурс и для чтения и записи.

### 4. Чем отличаются буферизированные и не буферизированные каналы?

- Небуфферизированные каналы не имеют буфера и требует блокировки отправителя
и получателя при передаче данных. Буфферизированные каналы позволяют отправителю
передавать данные, даже если получатель не готов к приему

### 5. Какой размер у структуры struct{}{}?

- 0 байт.

### 6. Есть ли в Go перегрузка методов или операторов?

- Нет

### 7. В какой последовательности будут выведены элементы map[int]int?
```
Пример:
m[0]=1
m[1]=124
m[2]=281
```
- В случайной. Golang не гарантирует порядок элементов map при обходе.

### 8. В чем разница make и new?

- make возвращает инициализированный тип, new - указатель на тип с его нулевым значением.
make используется только для типов slice, map, chan.

### 9. Сколько существует способов задать переменную типа slice или map?

```
a := []int{}
b := make([]int, 0)
c := make(map[int]int)
```

### 10. Что выведет данная программа и почему?
```
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
1 и 1. Если посмотреть адреса p в main и update, то станет понятно, что это
разные указатели, указывающие на один и тот же участок памяти. Чтобы исправить,
можно принимать в update указатель на указатель, либо разыменовав p, присвоить значение.

### 11. Что выведет данная программа и почему?
```
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
Получим deadlock, поскольку горутины в цикле, работают с копией wg.
Для решения проблемы, можно передать wg по указателю.

### 12. Что выведет данная программа и почему?
```
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Выведет 0. Внутри условия создается новая переменная n, которая удаляется, при
выходе из зоны видимости.

### 13. Что выведет данная программа и почему?
```
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
100, 2, 3, 4, 5. Слайс является структурой, внутри которой указатель на массив.
В функции будет копия слайса. При операции индексации, обращение идет напрямую
к массиву, а в копии слайса, указатель на на тот же массив, что и у изначального
слайса. Затем, append вернет новый слайс, который присваивается копии, что никак
не повлияет на изначальный слайс. Решить эту проблему можно, если передавать
слайс по указателю.

### 14. Что выведет данная программа и почему?
```
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
b b a, a a. Проблема та же, что и в предыдущем задании. Только на этот раз,
в начале копии присваивается новый слайс, а уже затем идет операция индексации.
Поэтому изначальный слайс никак не изменился. 